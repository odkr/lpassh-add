#!/bin/sh
# lpass-ssh-add v1.1.1b - Unlock SSH keys using LastPass.
#
# Copyright 2018, 2019, 2020 Odin Kroeger
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# See <https://github.com/okroeger/lpassh-add/> for more information.
#
#
# PORTABILITY
# ===========
#
# This script complies with POSIX.1-2017 and aims to be compatible to SVR4.2.
#
# See:
# * <https://www.gnu.org/software/autoconf/manual/autoconf-2.69/html_node/Portable-Shell.html>
# * <https://www.in-ulm.de/~mascheck/bourne/>


# FUNCTIONS
# =========

# onexit - Run code on exit.
# 
# Synopsis:
#   onexit SIGNO
#
# Description:
#   * Runs the shell code in the global variable $EX.
#   * If SIGNO is greater than 0, propagates that signal to the process group.
#   * If SIGNO isn't given or 0, terminates all children.
#   * Exits the script.
#
# Arguments:
#   SIGNO (integer):
#       A signal number.
#
# Global variables:
#   EX (string): 
#       Code to be run. Unset thereafter.
#   TRAPS (space-separated list of integers):
#       Signal numbers traps have been registered for (read-only).
# 
# Exits with:
#   The value of $? at the time it was called.
onexit() {
    __ONEXIT_STATUS=$?
    # shellcheck disable=2086
    trap '' ${TRAPS-2 15} || :
    set +e
    if [ "${EX-}" ]; then
        eval "$EX"
        unset EX
    fi
    if [ "${1-0}" -gt 0 ]
        then kill "-$1" "-$$"
        else jobs -p | xargs kill
    fi 2>/dev/null
    exit "$__ONEXIT_STATUS"
}

# trapsig - Register functions to trap signals.
#
# Synopsis:
#   trapsig FUNCTION SIGNO
#
# Description:
#   Registers FUNCTION to handle SIGNO.
#
# Arguments:
#   FUNCTION (string):
#       A shell function.
#   SIGNO (integer):
#       A signal number or 0 for "on programme exit".
#
# Global variables:
#   TRAPS (space-separated list of integers):
#       Signal numbers traps have been registered for. 
#       Adds every SIGNO to TRAPS.
#
# Returns:
#   0:
#       Always.
trapsig() {
    __TRAPSIG_FUNC="${1:?'missing FUNCTION.'}"
    shift
    for __TRAPSIG_SIGNO
    do
        # shellcheck disable=2064
        trap "$__TRAPSIG_FUNC $__TRAPSIG_SIGNO" "$__TRAPSIG_SIGNO"
        # shellcheck disable=2086
        for __TRAPSIG_TRAPPED in 0 ${TRAPS-}
        do
            [ "$__TRAPSIG_SIGNO" -eq "$__TRAPSIG_TRAPPED" ] && continue 2
        done
        TRAPS="${TRAPS-} $__TRAPSIG_SIGNO"
    done
}

# b_printf - printf wrapper.
#
# Rationale:
#   On some systems, printf is a utility, rather than a shell builtin.
#   This wrapper ensures that the shell can only invoke a built-in printf.
b_printf() (
    [ $# -gt 0 ] || panic 70 'printf: missing arguments.'
    unset PATH
    # shellcheck disable=2059
    printf -- "$@"
)

# warns - Prints a message to STDERR.
#
# Synopsis:
#   warn MESSAGE [ARG [ARG [...]]]
#
# Description:
#   * Formats MESSAGE with the given ARGs (think printf).
#   * Prefixes the message with "lpassh-add: ", appends a linefeed,
#     and prints the message to STDERR.
#
# Arguments:
#   MESSAGE (string):
#       The message.
#   ARG (any):
#       Arguments for MESSAGE (think printf).
#
# Returns:
#   0:
#       Always.
warn() (
    string="${1:?'warn: missing MESSAGE.'}"
    shift
    # shellcheck disable=2059
    case $# in
        0) printf -- 'lpassh-add: %s\n' "$string"  ;;
        *) printf -- "lpassh-add: $string\\n" "$@" ;;
    esac >&2
)

# panic - Exits the script with an error message.
#
# Synopsis:
#   panic [STATUS [MESSAGE [ARG [ARG [...]]]]]
#
# Description:
#   * Prints MESSAGE to STDERR, as warn would.
#   * Exits the programme with STATUS.
#
# Arguments:
#   STATUS (integer):
#       The status to exit with. Defaults to 69.
#
#   See warn for the remaing arguments.
#
# Exits with:
#   STATUS
# shellcheck disable=2059
panic() {
    set +eu
    __PANIC_STATUS="${1:-69}"
    if [ $# -gt 0 ]; then
        shift
        [ $# -gt 0 ] && warn "$@"
    fi
    exit "$__PANIC_STATUS"
}

# auth_lpass - Run lpass, but authenticate using a given password.
#
# Synopsis:
#   auth_lpass [...]
#
# Description:
#   Calls lpass and passes on all of its arguments to it.
#   Also prints the content of the global variable $LASTPASS_PASSWORD to its STDIN.
#
# Arguments:
#   Are passed on to lpass.
#
# Global variables:
#   LASTPASS_PASSWORD (string):
#       The LastPass master password (read-only).
#
# Returns:
#   Whatever lpass returns.
auth_lpass() {
    [ $# -gt 0 ] || panic 70 'auth_lpass: missing arguments.'
    b_printf '%s\n' "$LASTPASS_PASSWORD" |
    LPASS_DISABLE_PINENTRY=1 lpass "$@"
}


# SETTINGS
# ========

# shellcheck disable=2039
[ "$BASH_VERSION" ] && set -o posix
[ "$ZSH_VERSION"  ] && emulate sh 2>/dev/null
# shellcheck disable=2034
BIN_SH=xpg4 NULLCMD=: POSIXLY_CORRECT=x CLICOLOR_FORCE=
export BIN_SH CLICOLOR_FORCE POSIXLY_CORRECT

set -Cefu
umask 077

: "${LPASSH_ADD_PATH_REGEX=ssh}"
export LPASS_AUTO_SYNC_TIME=30

case "${LPASSH_ADD_AGENT_DISABLE-}" in
    0|1) export LPASS_AGENT_DISABLE="$LPASSH_ADD_AGENT_DISABLE";;
esac


# SANITISE ENVIRONMENT
# ====================

# Set a secure path.
PATH=/bin:/usr/bin:/usr/local/bin
# shellcheck disable=2006
PATH="`getconf PATH`:$PATH"
unset IFS
: "${HOME:?'Not set or empty.'}"

# SERVE PASSWORD TO SSH-ADD
# =========================

# ssh-add reads passphrases from the terminal's teletype device by default.
# So, to pass on passphrases to it, this script sets itself as SSH_ASKPASS
# utility (see below) and then, when it's called by ssh-add, simply calls
# cat to pass through STDIN to STDOUT. Thereby, it can pass on passphrases
# to ssh-add by writing them to its STDIN.

[ "${SSH_ASKPASS-}" = "$0" ] && exec cat


# INITIALISATION
# ==============

# Parse arguments.
while [ $# -gt 0 ]
do
    ARG="$1"
    case $ARG in
        -[cq])
            shift
            OPTS="${OPTS-} $ARG"
            [ "$ARG" = -q ] && QUIET=x
            ;;
        -t)
            [ "${2-}" ] || panic 64 '%s: Missing lifetime.' "$ARG"
            OPTS="${OPTS-} $ARG $2"
            shift 2
            ;;
        -[ADdeEkKLlsXx])
            panic 64 '%s: Unsupported option.' "$ARG"
            ;;
        -h)
            exec cat <<EOF
lpassh-add v1.1.1b - Unlocks SSH keys using LastPass.

Synopsis:
    lpassh-add [-ckq] [-t LIFETIME] [*KEY* [*KEY* [...]]]

Arguments:
    KEY          The key to unlock. If no KEY is given, tries
                 ~/.ssh/id_rsa, ~/.ssh/id_dsa, ~/.ssh/id_ecdsa,
                 and ~/.ssh/id_ed25519.

Options:
    -c           Confirm every use of an identity.
    -h           Show this help screen.
    -q           Be quieter.
    -t LIFETIME  Automatically re-lock keys after LIFETIME.
    -V           Show version.

See the manual for details.
EOF
            ;;
        -V)
            exec cat <<EOF
lpassh-add v1.1.1b
(c) 2018, 2019, 2020 Odin Kroeger
Released under the MIT license.
EOF
            ;;
        --)
            shift
            break
            ;;

        -*)
            panic 64 '%s: Unknown option.' "$ARG"
            :
            ;;
        *)
            break
            ;;
    esac
done

# Check if keys have been given.
# shellcheck disable=2121
if [ $# -eq 0 ]; then
    SSH_HOME="$HOME/.ssh"
    set -- "$SSH_HOME/id_rsa"   "$SSH_HOME/id_dsa"     \
           "$SSH_HOME/id_ecdsa" "$SSH_HOME/id_ed25519"
else
    KEYS_GIVEN=x
fi

# Make sure LPASS_ASKPASS and SSH_ASKPASS point to a system programme.
for UTIL in "${LPASS_ASKPASS-}" "${SSH_ASKPASS-}"
do
    [ "${UTIL-}" ] || continue
    # shellcheck disable=2006,2046
    if [ "$UTIL" = `expr "//$UTIL" : '.*/\(.*\)'` ]; then
        ASKPASS="$UTIL"
        break
    else
        (
            IFS=/
            for ELEM in $UTIL
            do
                unset IFS
                [ "$ELEM" ] || continue
                ACC="${ACC-}/$ELEM"
                # shellcheck disable=2012,2121         
                set -- `ls -d -l -n "${ACC:?}" | awk '{print $1, $3, $4}'`
                [ $# -eq 3 ]      \
                    || panic 69 "%s: Can't parse stats." "$ACC"
                [ "$2" -eq 0 ]    \
                    || panic 69 '%s: Not owned by root.' "$ACC"
                [ "$3" -lt 1000 ] \
                    || panic 69 '%s: Not owned by a system group.' "$ACC"
                PERMS="$1"
                case ${PERMS#????} in
                    *w*) panic 69 '%s: Non-owner writeable.' "$ACC" ;;
                esac
            done
        ) || panic 69 '%s: Not secure.' "$UTIL"
        ASKPASS="$UTIL"
        break
    fi
done
export PATH IFS

# Prepare cleanup.
trapsig onexit 0 2 15


# MAIN
# ====

# Log into LastPass if necessary.
LPASS=lpass LASTPASS_STATUS=0 LASTPASS_PASSWORD=
lpass status --quiet || LASTPASS_STATUS=$?
if [ "$LASTPASS_STATUS" -ne 0 ]; then
    [ "${LPASSH_ADD_USERNAME-}" ] || panic 64 'Not logged into LastPass.'
    if [ "${LPASS_AGENT_DISABLE-0}" -eq 1 ]; then
        PROMPT='LastPass master password:'
        if [ "${ASKPASS-}" ]; then
            warn 'ID of process calling %s: %d.' "$ASKPASS" "$$"
            # shellcheck disable=2006
            LASTPASS_PASSWORD=`$ASKPASS "$PROMPT"`
        else
            # shellcheck disable=2006
            TTY=`tty`
            [ -c "$TTY" ] || panic 69 "No TTY. Can't ask for password."
            readonly TTY
            # shellcheck disable=2031
            OLD_EX="${EX-}"; 
            # shellcheck disable=2031
            EX="stty echo <\"\$TTY\"; echo >\"\$TTY\"; ${EX-}"
            stty -echo <"$TTY"
            printf -- '%s ' "$PROMPT" >"$TTY"
            read -r LASTPASS_PASSWORD <"$TTY"
            stty echo  <"$TTY"
            echo >"$TTY"
            EX="$OLD_EX"
        fi
        [ "$LASTPASS_PASSWORD" ] || panic 64 'No password given.'
        LPASS=auth_lpass
        # Make sure lpass reads from STDIN.
        if [ "${LASTPASS-}" ] || [ "${LASTPASS-x}" = x ]; then
            unset LPASS_ASKPASS
            export LPASS_ASKPASS
        fi
    fi
    "$LPASS" login --color=never "$LPASSH_ADD_USERNAME" 1>/dev/null \
        || panic 69 'Could not log into LastPass.'
    # shellcheck disable=2016
    EX="lpass logout --force >/dev/null"
fi

# Lookup IDs of all SSH keys.
# shellcheck disable=2006
IDS=`"$LPASS" show --id -x -G "$LPASSH_ADD_PATH_REGEX"`
[ "$IDS" ] || panic 69 '%s: No LastPass items match.' "$LPASSH_ADD_PATH_REGEX"

# Unlock the keys.
NOT_FOUND=0
for KEY
do
    if [ -e "$KEY" ]; then
        for ID in $IDS
        do
            # shellcheck disable=2086
            "$LPASS" show --field=Passphrase "$ID" |
            SSH_ASKPASS="$0" DISPLAY='' ssh-add ${OPTS-} "$KEY" && continue 2
        done
        [ "${QUIET-}" ] || warn '%s: No matching passphrases in LastPass.' "$KEY"
        NOT_FOUND=$((NOT_FOUND+1))
        eval "KEY_$NOT_FOUND=\"\$KEY\""
    elif [ "${KEYS_GIVEN-}" ]; then
        warn '%s: No such file.' "$KEY"
    fi
done
[ "$NOT_FOUND" -eq 0 ] && exit

set -- "$KEY_1"
ITER=2
while [ $ITER -le $NOT_FOUND ]
do
    eval "KEY=\"\$KEY_$ITER\""
    set -- "$@" "$KEY"
    ITER=$((ITER+1))
done

# shellcheck disable=2086
ssh-add ${OPTS-} "$@"
