#!/bin/sh
# lpass-ssh-add v1.0.6b - Get SSh private key passphrases from LastPass
#
# Copyright 2018, 2019 Odin Kroeger
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# See <https://github.com/okroeger/lpassh-add/> for more information.
#
#
# PORTABILITY
# ===========
#
# This script complies with the Shell Command Language as POSIX.1-2017 defines 
# it. Morever, it aims to be SVR4.2 compatible, which requires it to run on 
# shells that are buggy, necessitating some weird constructs; in order of
# appearance:
#
# onexit():
# * I use:
#       VAR=''
#
#   Instead of:
#       unset VAR
#
# onexit(), main script:
# * I use:
#       command || ...
#   Or
#       command || { ... }
#
#   Instead of:
#       if ! command; then ...
#
# regex():
# * I use:
#       foo=`sed 'pattern' <<EOF
#       $bar
#       EOF`
#
#   Instead of:
#       foo="${bar#pattern}"
#
# main script:
# * I use:
#       cat <<EOF
#       $var
#       EOF
#
#   Instead of:
#       echo "$var"
#
#   Or:
#       printf -- '%s\n' "$var"
#
#   Neither `echo` nor `printf` are safe with arbitrary input.
#   Also, in some shells `echo` and `printf` are not builtins, to the
#   effect that they, and "$var", would show up in the output of `ps`.
#   This would allow any user on a system to snoop passwords.
#
# * I use:
#       `...`
#
#   Instead of:
#       $(...)
#
# * I test whether any arguments have been passed before referencing `$@`
#   because some shells will abort if `$@` is referenced but no arguments
#   have been given and `set -u` is in effect.
#
# * I create temporary directories myself, instead of using `mktemp` or
#   `m4`. POSIX does not require `mktemp`. And many Linux distributions
#   don't ship with `m4`.


# FUNCTIONS
# =========

# Runs `$EX`, propagates the signal received, if any, kills children, and exits.
onexit() {
    __ONEXIT_STATUS=$?
    # shellcheck disable=2086
    trap '' ${TRAPS-2 3 15} || :
    set +e
    if [ "${EX-}" ]; then
        eval "$EX"
        EX=''
    fi
    # shellcheck disable=2006
    if [ "${1-0}" -gt 0 ]; then
        kill "-$1" "-$$"
    else
        # shellcheck disable=2046
        __ONEXIT_CHILDREN=`jobs -p 2>/dev/null`
        # shellcheck disable=2086
        [ "${__ONEXIT_CHILDREN-}" ] && kill $__ONEXIT_CHILDREN 2>/dev/null
    fi
    exit "$__ONEXIT_STATUS"
}

# Registers a HANDLER for signals. Has the same function signature as `trap`.
# Stores every signal it registers a HANDLER for into the global $TRAPS.
trapsig() {
    __TRAPSIG_HANDLER="${1:?'missing HANDLER.'}"
    shift
    for __TRAPSIG_SIGNAL
    do
        # shellcheck disable=2064
        trap "$__TRAPSIG_HANDLER $__TRAPSIG_SIGNAL" "$__TRAPSIG_SIGNAL"
        # shellcheck disable=2086
        contains "$__TRAPSIG_SIGNAL" EXIT 0 ${TRAPS:=} || \
            TRAPS="$TRAPS $__TRAPSIG_SIGNAL"
    done
}

# Takes a MESSAGE and ARGUMENTS (think `printf`) and
# prints the formated MESSAGE to STDERR.
warn() (
    message="${1:?'warn: missing MESSAGE.'}"
    shift
    # shellcheck disable=2059
    case $# in
        0) printf 'lpassh-add: %s\n' "$message" >&2 ;;
        *) printf -- "lpassh-add: $message\\n" "$@" >&2 ;;
    esac
)

# Takes an exit STATUS, a MESSAGE, and ARGUMENTS,
# prints the MESSAGE to STDERR and exits with STATUS.
# shellcheck disable=2059
panic() {
    set +eu
    __PANIC_STATUS="${1:?'panic: missing STATUS.'}"
    shift
    [ $# -gt 0 ] && warn "$@"
    exit "$__PANIC_STATUS"
}

# Copies content of variable SOURCE to variable TARGET. 
var_cp() {
    [ $# -eq 2 ] || panic 70 'usage: var_cp SOURCE TARGET.'
    for __VAR_CP_VARNAME
    do
        case $__VAR_CP_VARNAME in
            *[!A-Za-z0-9_]*)
                panic 70 '%s: Not a variable name.' "$__VAR_CP_VARNAME"
                ;;
        esac
    done
    eval "$2=\"\${$1-}\""
}

# Takes a NEEDLE and a HAYSTACK as arguments,
# returns true if NEEDLE is in HAYSTACK.
contains() (
    needle="${1:?'contains: missing NEEDLE.'}"
    shift
    for straw
    do [ "$needle" = "$straw" ] && return
    done
    return 1
)

# Takes a REGEX and a STRING as arguments,
# applies REGEX to STRING, and prints the result.
regex() {
    sed "${1:?'regex: missing REGEX.'}" <<EOF
$2
EOF
}

# Takes a prompt as argument and asks for a password.
# shellcheck disable=2006
askpass() (
    prompt="${1:?'missing PROMPT'}" tty="${2-}" util="${3-}"
    if [ "$util"   ]; then
        # shellcheck disable=2016
        warn 'ID of process calling %s: %d.' \
            "$util" "`exec sh -c 'echo $PPID'`"
        "$util" "$prompt"
    elif [ -c "$tty" ]; then
        trapsig onexit 0 2 3 15
        exec 0<"$tty"
        # shellcheck disable=2016
        EX='stty echo 2>/dev/null; exec 0<&-; echo >&2'
        stty -echo
        printf -- '%s: ' "$prompt" >&2
        read -r pass
        cat <<EOF
$pass
EOF
    else
        panic 69 'No TTY. Cannot ask for password.'
    fi
)

# Takes a PASSWORD and ARGUMENTS for `lpass` and
# runs `lpass` with ARGUMENTS, authenticating with PASSWORD.
auth_lpass() (
    password="${1?'auth_lpass: missing PASSWORD.'}"
    shift
    [ $# -gt 0 ] || panic 70 'auth_lpass: missing arguments for lpass.'
    exec lpass "$@" <<EOF
$password
EOF
)


# SETTINGS
# ========

# shellcheck disable=2039
[ "$BASH_VERSION" ] && set -o posix
[ "$ZSH_VERSION" ]  && emulate sh 2>/dev/null
# shellcheck disable=2034
BIN_SH=xpg4 NULLCMD=:
export BIN_SH

set -Cefu
umask 077

: "${LPASSH_ADD_LASTPASS_FOLDER:=SSh keys}"
[ "${LPASS_AGENT_DISABLE-0}"    -eq 1 ] || LPASS_AGENT_DISABLE=1
[ "${LPASS_DISABLE_PINENTRY-0}" -eq 1 ] || LPASS_DISABLE_PINENTRY=1
[ "${LPASS_AGENT_PINENTRY-}" ]          && LPASS_PINENTRY=''
LPASS_AUTO_SYNC_TIME=30
export LPASS_AGENT_DISABLE LPASS_DISABLE_PINENTRY \
    LPASS_PINENTRY LPASS_AUTO_SYNC_TIME


# WORKER
# ======

if [ "${SSH_ASKPASS-}" = "$0" ]; then
    # Check which key `ssh-add` tries to unlock.
    PROMPT="$*"
    # shellcheck disable=2006
    PRIVKEY_NEEDLE_FILE=`regex 's/^[^\/]\{1,\}//; s/: $//' "$PROMPT"`

    # Check whether we should unlock that key.
    IFS=:
    if [ "${LPASSH_ADD_KEYS-}" ]; then
        contains "$PRIVKEY_NEEDLE_FILE" "${LPASSH_ADD_KEYS-}" || exit 1
    fi
    if [ "${LPASSH_ADD_IGNORE_KEYS-}" ]; then
        contains "$PRIVKEY_NEEDLE_FILE" "${LPASSH_ADD_IGNORE_KEYS-}" && exit 1
    fi
    unset IFS

    # Query the parent process for the password.
    cat >&3 <<EOF
$PRIVKEY_NEEDLE_FILE
EOF

    # Read the response.
    read -r PASSWORD || ERR=$?
    if [ "${ERR-0}" -gt 1 ]; then
        warn 'read: Returned %d.' "$ERR"
        exit 69
    fi

    # Pass it on to `ssh-add`.
    exec cat <<EOF
$PASSWORD
EOF
fi


# INITIALISATION
# ==============

# Set a secure path.
PATH=/bin:/usr/bin:/usr/local/bin
# shellcheck disable=2006
PATH="`getconf PATH`:$PATH"

# Make sure no fancy input field separator is set.
unset IFS

# Parse arguments
if [ $# -gt 0 ]; then
    for ARG
    do
        case $ARG in
            -h|--help)
                exec cat <<EOF
usage: lpassh-add [options] [file ...]
lpassh-add accepts the same arguments as ssh-add.
EOF
                ;;
            --version)
                exec cat <<EOF
lpassh-add v1.0.6b
(c) 2018, 2019 Odin Kroeger
EOF
                ;;
            --)
                break
                ;;
            -*)
                :
                ;;
            *)
                break
                ;;
        esac
    done
fi

# Make sure the temporary directory is set.
: "${TMPDIR:=${HOME:?'Not set or empty.'}}"

# Make sure SSH_ASKPASS points to a system programme.
if [ "${SSH_ASKPASS-}" ]; then
    # shellcheck disable=2006,2046
    if [ "$SSH_ASKPASS" = `basename "$SSH_ASKPASS"` ]; then
        MY_ASKPASS="$SSH_ASKPASS"
    else
        IFS=/
        for ELEM in $SSH_ASKPASS
        do
            unset IFS
            [ "$ELEM" ] || continue
            ACC="${ACC-}/$ELEM"
            # shellcheck disable=2006,2012
            set -- `ls -d -l -n "${ACC:?}" | awk '{print $1, $3, $4}'`
            [ $# -eq 3 ]      \
                || panic 79 '%s: Cannot parse path.' "$ACC"
            [ "$2" -eq 0 ]    \
                || panic 69 '%s: Not owned by root.' "$ACC"
            [ "$3" -lt 1000 ] \
                || panic 69 '%s: Not owned by a system group.' "$ACC"
            PERMS="$1"
            case ${PERMS#????} in
                *w*) panic 69 '%s: Non-owner writeable.' "$ACC" ;;
            esac
        done
        MY_ASKPASS="$SSH_ASKPASS"
    fi
fi
export PATH IFS PWD

# Check what TTY to read passwords from.
# shellcheck disable=2006
TTY=`tty` || :
[ "$TTY" ] || panic 69 'Cannot determine TTY.'

# Prepare cleanup.
trapsig onexit 0 2 3 15

# Make temporary directory.
# shellcheck disable=2006,2039
: "${RANDOM:=`awk 'BEGIN{srand; printf "%x\n", rand * 16^5}' </dev/null`}"
# shellcheck disable=2039
TMP_NAME="$RANDOM-$$"
# shellcheck disable=2006
NAME_MAX=`getconf NAME_MAX "$TMPDIR" 2>/dev/null` || NAME_MAX=14
[ "$NAME_MAX" -ge 24  ] && TMP_NAME="lpassh-add.$TMP_NAME"
[ "$HOME" = "$TMPDIR" ] && TMP_NAME=".$TMP_NAME"
readonly PRIV_TMPDIR="$TMPDIR/$TMP_NAME"
EX="[ \"\${PRIV_TMPDIR-}\" ] && rm -rf \"\$PRIV_TMPDIR\""
mkdir -m 0700 "$PRIV_TMPDIR" || exit 69
# shellcheck disable=2034
export TMPDIR="$PRIV_TMPDIR"

# Log into LastPass if necessary.
PASSWORD=''
lpass status --quiet || {
    [ "${LPASSH_ADD_USERNAME-}" ] || panic 64 'Not logged into LastPass.'
    # shellcheck disable=2006
    PASSWORD=`askpass 'LastPass master password' "$TTY" "${MY_ASKPASS-}"`
    [ "${PASSWORD-}" ] || panic 64 'No password given.'
    auth_lpass "$PASSWORD" login --color=never "$LPASSH_ADD_USERNAME" \
        1>/dev/null 2>&1 || panic 69 'Could not log into LastPass.'
    # shellcheck disable=2016
    EX="lpass logout --force >/dev/null; $EX"
}

# Lookup the LastPass IDs of all SSh keys.
# shellcheck disable=2006
KEY_IDS=`auth_lpass "$PASSWORD" ls "$LPASSH_ADD_LASTPASS_FOLDER" |
         sed -n 's/.*\[id: \([[:digit:]]\{1,\}\)\]/\1/p'` || ERR=$?
[ "${ERR-0}" -eq 0 ] || \
    panic 69 'Could not obtain IDs of SSh keys from LastPass.'
[ "$KEY_IDS" ] || panic 0 'No SSh keys found in LastPass.'

# Create a FIFO to accept queries from the worker.
PIPE="$PRIV_TMPDIR/pipe"
mkfifo -m 0700 "$PIPE" || exit


# MAIN
# ====

# shellcheck disable=2094
while read -r PRIVKEY_NEEDLE_FILE; do
    # Read the public key file.
    [ "$PRIVKEY_NEEDLE_FILE" ] || continue
    read -r PUBKEY_NEEDLE <"$PRIVKEY_NEEDLE_FILE.pub" || ERR=$?
    if [ ${ERR-0} -gt 1 ]; then 
        warn 'read: Returned %d.' "$ERR"
        continue
    fi

    # Search the public key that the worker has asked for.
    HIT=''
    for ID in $KEY_IDS; do
        # Cache the result.
        var_cp "PUBKEY_$ID" PUBKEY
        if ! [ "$PUBKEY" ]; then
            # shellcheck disable=2006
            PUBKEY=`auth_lpass "$PASSWORD" show --field='Public Key' "$ID"`
            [ "$PUBKEY" ] || PUBKEY="<not found>"
            var_cp PUBKEY "PUBKEY_$ID"
        fi

        # Tell the worker the password.
        if [ "$PUBKEY" = "$PUBKEY_NEEDLE" ]; then
            auth_lpass "$PASSWORD" show --field=Passphrase "$ID" || ERR=$?
            if [ "${ERR-0}" -ne 0 ]; then
                warn 'lpass: Returned %d.' "$ERR"
                continue
            fi
            HIT=x
            break
        fi
    done

    # Ask for the password if we didn't find it in LastPass.
    [ "$HIT" ] && continue
    warn '%s: Not found in LastPass.' "$PRIVKEY_NEEDLE_FILE"
    askpass "Passphrase for $PRIVKEY_NEEDLE_FILE" "$TTY" "${MY_ASKPASS-}"
done <"$PIPE" | 
(
    trapsig onexit 0 2 3 15
    # shellcheck disable=2016
    EX='exec 3>&-'
    exec 3>"$PIPE"
    rm -f "$PIPE"

    case $# in
        0) SSH_ASKPASS="$0" DISPLAY='' LC_ALL=C ssh-add "$@" ;;
        *) SSH_ASKPASS="$0" DISPLAY='' LC_ALL=C ssh-add ;;
    esac
)