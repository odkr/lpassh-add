#!/bin/sh
# lpass-ssh-add v1.0.6b - Get SSh private key passphrases from LastPass
#
# Copyright 2018, 2019 Odin Kroeger
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# See <https://github.com/okroeger/lpassh-add/> for more information.
#
#
# PORTABILITY
# ===========
#
# This script complies with the Shell Command Language as POSIX.1-2017 defines 
# it. Morever, it aims to be SVR4.2 compatible, which requires it to run on 
# shells that are buggy, necessitating some weird constructs; in order of
# appearance:
#
# onexit():
# * I use:
#       VAR=''
#
#   Instead of:
#       unset VAR
#
# onexit(), main script:
# * I use:
#       command || ...
#   Or
#       command || { ... }
#
#   Instead of:
#       if ! command; then ...
#
# regex():
# * I use:
#       foo=`sed 'pattern' <<EOF
#       $bar
#       EOF`
#
#   Instead of:
#       foo="${bar#pattern}"
#
# main script:
# * I use:
#       cat <<EOF
#       $var
#       EOF
#
#   Instead of:
#       echo "$var"
#
#   Or:
#       printf -- '%s\n' "$var"
#
#   Neither `echo` nor `printf` are safe with arbitrary input.
#   Also, in some shells `echo` and `printf` are not builtins, to the
#   effect that they, and "$var", would show up in the output of `ps`.
#   This would allow any user on a system to snoop passwords.
#
# * I use:
#       `...`
#
#   Instead of:
#       $(...)
#
# * I test whether any arguments have been passed before referencing `$@`
#   because some shells will abort if `$@` is referenced but no arguments
#   have been given and `set -u` is in effect.


# FUNCTIONS
# =========

# Runs `$EX`, terminates all children, and exits.
onexit() {
    __ONEXIT_STATUS=$?
    trap '' 1 2 3 15 || :
    set +e
    if [ "${EX-}" ]; then
        eval "$EX"
        EX=''
    fi
    kill -15 -$$
    exit "$__ONEXIT_STATUS"
}

# Takes a MESSAGE and ARGUMENTS (think `printf`) and
# prints the formated MESSAGE to STDERR.
warn() (
    message="${1:?'warn: missing MESSAGE.'}"
    shift
    # shellcheck disable=2059
    printf -- "lpassh-add: $message\\n" "$@" >&2
)

# Takes an exit STATUS, a MESSAGE, and ARGUMENTS,
# prints the MESSAGE to STDERR and exits with STATUS.
# shellcheck disable=2059
panic() {
    set +eu
    __PANIC_STATUS="${1:?'panic: missing STATUS.'}"
    shift
    warn "$@"
    exit "$__PANIC_STATUS"
}

# Takes a NEEDLE and a HAYSTACK as arguments,
# returns true if NEEDLE is in HAYSTACK.
contains() (
    needle="${1:?'contains: missing NEEDLE.'}"
    shift
    for straw
    do [ "$needle" = "$straw" ] && return
    done
    return 1
)

# Takes a REGEX and a STRING as arguments,
# applies REGEX to STRING, and prints the result.
regex() {
    sed "${1:?'regex: missing REGEX.'}" <<EOF
$2
EOF
}

# Takes a DEVICE and checks if it refers to a TTY device.
isatty() {
    : "${1:?'isatty: missing DEVICE.'}"
    [ "$1" != "not a tty" ] && [ -c "$1" ]
}

# Takes a prompt as argument and asks for a password.
# shellcheck disable=2006
askpass() (
    trap onexit 0 1 2 3 15
    # shellcheck disable=2046
    cat <<EOF | tr -d '\n' >&2
$*
EOF
    # shellcheck disable=2016
    EX='stty echo 2>/dev/null; [ "$1" = 0 ] && echo >&2'
    stty -echo
    pass=''
    read -r pass
    cat <<EOF
$pass
EOF
)

# Takes a PASSWORD and ARGUMENTS for `lpass` and
# runs `lpass` with ARGUMENTS, authenticating with PASSWORD.
auth_lpass() (
    password="${1:?'auth_lpass: missing PASSWORD.'}"; shift
    exec lpass "$@" <<EOF
$password
EOF
)


# SETTINGS
# ========

# shellcheck disable=2039
[ "$BASH_VERSION" ] && set -o posix
[ "$ZSH_VERSION" ]  && emulate sh 2>/dev/null
# shellcheck disable=2034
BIN_SH=xpg4 NULLCMD=:
export BIN_SH

set -Cefu
umask 077

: "${LPASSH_ADD_LASTPASS_FOLDER:=SSh keys}"
[ "${LPASS_AGENT_DISABLE-0}"    -eq 1 ] || LPASS_AGENT_DISABLE=1
[ "${LPASS_DISABLE_PINENTRY-0}" -eq 1 ] || LPASS_DISABLE_PINENTRY=1
[ "${LPASS_AGENT_PINENTRY-}" ]          && LPASS_PINENTRY=''
LPASS_AUTO_SYNC_TIME=30
export LPASS_AGENT_DISABLE LPASS_DISABLE_PINENTRY \
    LPASS_PINENTRY LPASS_AUTO_SYNC_TIME


# INITIALISATION
# ==============

if [ -z "${__LPASSH_ADD_TTY-}" ]; then
    # Set a secure path.
    PATH=/bin:/usr/bin:/usr/local/bin
    # shellcheck disable=2006
    PATH="$PATH:"`getconf PATH`

    # Make sure no fancy input field separator is set.
    unset IFS

    # Make sure the temporary directory is set.
    : "${TMPDIR:=${HOME:?'not set or empty.'}}"

    # Make sure SSH_ASKPASS points to a system programme.
    if [ "${SSH_ASKPASS-}" ]; then
        # shellcheck disable=2006,2046
        if [ "$SSH_ASKPASS" = `basename "$SSH_ASKPASS"` ]; then
            __LPASSH_ADD_ASKPASS="$SSH_ASKPASS"
        else
            (
                IFS=/
                for elem in $SSH_ASKPASS; do
                    unset IFS
                    [ "$elem" ] || continue
                    path="${path-}/$elem"
                    # shellcheck disable=2006,2012
                    set -- `ls -d -l -n "${path:?}" | awk '{print $1, $3, $4}'`
                    [ $# -eq 3 ]      \
                        || panic 79 '%s: cannot parse path.' "$path"
                    [ "$2" -eq 0 ]    \
                        || panic 69 '%s: not owned by root.' "$path"
                    [ "$3" -lt 1000 ] \
                        || panic 69 '%s: not owned by a system group.' "$path"
                    case ${1#????} in
                        *w*) panic 69 '%s: non-owner writeable.' "$path";;
                    esac
                done
                exit 0
            ) || panic $? '%s: insecure.' "$SSH_ASKPASS"
            __LPASSH_ADD_ASKPASS="$SSH_ASKPASS"
        fi
    fi
    export PATH IFS PWD __LPASSH_ADD_ASKPASS

    # Parse arguments
    if [ $# -gt 0 ]; then
        for ARG
        do
            case $ARG in
                -h|--help)
                    exec cat <<EOF
usage: lpassh-add [options] [file ...]
lpassh-add accepts the same arguments as ssh-add.
EOF
                    ;;
                --version)
                    exec cat <<EOF
lpassh-add v1.0.5
(c) 2018 Odin Kroeger
EOF
                    ;;
                --)
                    break
                    ;;
                -*)
                    :
                    ;;
                *)
                    break
                    ;;
            esac
        done
    fi

    # Prepare temporary directory.
    trap onexit 0 1 2 3 15
    readonly LPASSH_ADD_TMPDIR="${TMPDIR%/}/lpassh-add"
    export LPASSH_ADD_TMPDIR
    TMPDIR_CREATED=''
    EX="[ \"\${TMPDIR_CREATED-}\" ] && rm -rf \"\$LPASSH_ADD_TMPDIR\""
    mkdir -m 0700 "$LPASSH_ADD_TMPDIR" || exit 69
    # shellcheck disable=2034
    TMPDIR_CREATED=x
    export TMPDIR="$LPASSH_ADD_TMPDIR"

    # Check if a we're logged into LastPass *or* a username has been given.
    lpass status --quiet || [ "${LPASSH_ADD_USERNAME-}" ] || \
        panic 69 'not logged into LastPass.'

    # Check what TTY to read passwords from.
    # shellcheck disable=2006
    __LPASSH_ADD_TTY=`tty` || :
    [ "$__LPASSH_ADD_TTY" ] || panic 69 'could not get TTY.'
    export __LPASSH_ADD_TTY

    # Call ssh-add.
    case $# in
        0) SSH_ASKPASS="$0" DISPLAY='' LC_ALL=C ssh-add "$@" ;;
        *) SSH_ASKPASS="$0" DISPLAY='' LC_ALL=C ssh-add ;;
    esac </dev/null
    exit
fi


# MAIN
# ====

# Check which key `ssh-add` tries to unlock.
PROMPT="$*"
# shellcheck disable=2006
PRIVKEY_NEEDLE_FILE=`regex 's/^[^\/]\{1,\}//; s/: $//' "$PROMPT"`

# Check whether we should unlock that key.
IFS=:
if [ "${LPASSH_ADD_KEYS-}" ]; then
    contains "$PRIVKEY_NEEDLE_FILE" "${LPASSH_ADD_KEYS-}"    || exit 1
fi
contains "$PRIVKEY_NEEDLE_FILE" "${LPASSH_ADD_IGNORE_KEYS-}" && exit 1
unset IFS

# Ask for LastPass password.
LPASS_PROMT='LastPass master password: '
if [ "${__LPASSH_ADD_ASKPASS-}" ]; then
    warn 'ID of process asking for passphrase: %d.' "$$"
    # shellcheck disable=2006
    PASSWORD=`"$__LPASSH_ADD_ASKPASS" "$LPASS_PROMT"`
elif isatty "$__LPASSH_ADD_TTY"; then
    # shellcheck disable=2006
    PASSWORD=`askpass "$LPASS_PROMT" <"$__LPASSH_ADD_TTY"`
else
    panic 64 "no tty, can't ask for LastPass master password."
fi
[ "${PASSWORD-}" ] || panic 64 'no password given, aborting.'
readonly PASSWORD

# Log into LastPass if necessary.
lpass status --quiet || {
    trap onexit 0 1 2 3 15
    auth_lpass "$PASSWORD" login --color=never "$LPASSH_ADD_USERNAME" \
        2>/dev/null 1>&2 || panic 69 'login to LastPass failed.'
    # shellcheck disable=2016
    EX='auth_lpass "$PASSWORD" logout --force 2>/dev/null 1>&2'
}

# Read the public key file.
read -r PUBKEY_NEEDLE <"$PRIVKEY_NEEDLE_FILE.pub" || ERR=$?
[ ${ERR-0} -gt 1 ] && exit 66

# Lookup the LastPass IDs of *all* SSh keys, caching the result.
{
    KEY_IDS="$LPASSH_ADD_TMPDIR/key_ids"
    if [ -e "$KEY_IDS" ]; then
        cat "$KEY_IDS" || exit 69
    else
        auth_lpass "$PASSWORD" ls "$LPASSH_ADD_LASTPASS_FOLDER" |
        sed -n 's/.*\[id: \([[:digit:]]\{1,\}\)\]/\1/p'         |
        tee "$KEY_IDS" 2>/dev/null
    fi
} | 

# Search the given key by its public key, caching the results,
# and print the passphrase to STDOUT.
{
    while read -r ID; do
        PUBKEY_STRAW_FILE="$LPASSH_ADD_TMPDIR/$ID"
        if [ -e "$PUBKEY_STRAW_FILE" ]; then
            read -r PUBKEY_STRAW <"$PUBKEY_STRAW_FILE" || ERR=$?
            [ ${ERR-0} -gt 1 ] && exit 66
        else
            # shellcheck disable=2006
            PUBKEY_STRAW=`auth_lpass "$PASSWORD" \
                show --field='Public Key' "$ID"`
            [ "${PUBKEY_STRAW-}" ] || continue
            cat <<EOF >"$PUBKEY_STRAW_FILE" || :
$PUBKEY_STRAW
EOF
        fi
        
        if [ "$PUBKEY_STRAW" = "$PUBKEY_NEEDLE" ]; then
            auth_lpass "$PASSWORD" show --field=Passphrase "$ID"
            exit
        fi
    done

    # If we reach this point, then we couldn't find the key.
    warn  '%s: not found in LastPass.' "$PRIVKEY_NEEDLE_FILE"
    if [ "${__LPASSH_ADD_ASKPASS-}" ]; then
        "$__LPASSH_ADD_ASKPASS" "$PROMPT"
    elif isatty "$__LPASSH_ADD_TTY"; then
        askpass "$PROMPT" <"$__LPASSH_ADD_TTY"
    else
        panic 64 "no tty, can't ask for passphrase."
    fi
}