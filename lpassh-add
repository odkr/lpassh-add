#!/bin/sh
# lpass-ssh-add v1.1.0b - Unlock SSh keys using LastPass.
#
# Copyright 2018, 2019, 2020 Odin Kroeger
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# See <https://github.com/okroeger/lpassh-add/> for more information.
#
#
# PORTABILITY
# ===========
#
# This script complies with POSIX.1-2017 and aims to be compatible to SVR4.2.
# This requires it to run on buggy shells, shells that are buggy. This, 
# in turn, necessitates some *weird* constructs.
#
# See:
# * <https://www.gnu.org/software/autoconf/manual/autoconf-2.69/html_node/Portable-Shell.html>
# * <https://www.in-ulm.de/~mascheck/bourne/>


# FUNCTIONS
# =========

# onexit - Run code on exit.
# 
# Synopsis:
#   onexit SIGNO
#
# Description:
#   * Runs the shell code in the global variable $EX.
#   * If SIGNO is greater than 0, propagates that signal to the process group.
#   * If SIGNO isn't given or 0, terminates all children.
#   * Exits the script.
#
# Arguments:
#   SIGNO (integer):
#       A signal number.
#
# Global variables:
#   EX (string): 
#       Code to be run. Unset thereafter.
#   TRAPS (space-separated list of integers):
#       Signal numbers traps have been registered for (read-only).
# 
# Exits with:
#   The value of $? at the time it was called.
onexit() {
    __ONEXIT_STATUS=$?
    # shellcheck disable=2086
    trap '' ${TRAPS-2 15} || :
    set +e
    if [ "${EX-}" ]; then
        eval "$EX"
        unset EX
    fi
    if [ "${1-0}" -gt 0 ]
        then kill "-$1" "-$$"
        else jobs -p | xargs kill
    fi 2>/dev/null
    exit "$__ONEXIT_STATUS"
}

# trapsig - Register functions to trap signals.
#
# Synopsis:
#   trapsig FUNCTION SIGNO
#
# Description:
#   Registers FUNCTIOn to handle SIGNO.
#
# Arguments:
#   FUNCTION (string):
#       A shell function.
#   SIGNO (integer):
#       A signal number or 0 for "on programme exit".
#
# Global variables:
#   TRAPS (space-separated list of integers):
#       Signal numbers traps have been registered for. 
#       Adds every SIGNO to TRAPS.
#
# Returns:
#   0:
#       Always.
trapsig() {
    __TRAPSIG_FUNC="${1:?'missing FUNCTION.'}"
    shift
    for __TRAPSIG_SIGNO
    do
        # shellcheck disable=2064
        trap "$__TRAPSIG_FUNC $__TRAPSIG_SIGNO" "$__TRAPSIG_SIGNO"
        # shellcheck disable=2086
        for __TRAPSIG_TRAPPED in 0 ${TRAPS-}; do
            [ "$__TRAPSIG_SIGNO" -eq "$__TRAPSIG_TRAPPED" ] && continue 2
        done
        TRAPS="${TRAPS-} $__TRAPSIG_SIGNO"
    done
}

# warns - Prints a message to STDERR.
#
# Synopsis:
#   warn MESSAGE [ARG [ARG [...]]]
#
# Description:
#   * Formats MESSAGE with the given ARGs (think printf).
#   * Prefixes the message with "lpassh-add: ", appends a linefeed,
#     and prints the message to STDERR.
#
# Arguments:
#   MESSAGE (string):
#       The message.
#   ARG (any):
#       Arguments for MESSAGE (think printf).
#
# Returns:
#   0:
#       Always.
warn() (
    string="${1:?'warn: missing MESSAGE.'}"
    shift
    # shellcheck disable=2059
    case $# in
        0) printf -- 'lpassh-add: %s\n' "$string"  ;;
        *) printf -- "lpassh-add: $string\\n" "$@" ;;
    esac >&2
)

# panic - Exits the script with an error message.
#
# Synopsis:
#   panic [STATUS [MESSAGE [ARG [ARG [...]]]]]
#
# Description:
#   * Prints MESSAGE to STDERR, as warn would.
#   * Exits the programme with STATUS.
#
# Arguments:
#   STATUS (integer):
#       The status to exit with. Defaults to 69.
#
#   See warn for the remaing arguments.
#
# Exits with:
#   STATUS
# shellcheck disable=2059
panic() {
    set +eu
    __PANIC_STATUS="${1:-69}"
    if [ $# -gt 0 ]; then
        shift
        [ $# -gt 0 ] && warn "$@"
    fi
    exit "$__PANIC_STATUS"
}

# askpass - Ask for a passphrase.
#
# Synopsis:
#   askpass PROMPT TTY [UTIL]
#
# Description:
#   Asks for a passphrase. If UTIL is given, prints its process ID to STDERR
#   and calls UTIL, passing PROMPT as first argument. UTIL should prompt the
#   user for a password and print the answer to STDOUT. If UTIL is *not* given,
#   then it prompts the user for the password on and reads the user's reponse
#   from TTY. If TTY hasn't been given, prints a warning to STDERR and returns
#   an error. Prints the passphrase it obtains to STDOUT.
#
# Arguments:
#   PROMPT (string):
#       The string to display to the user to ask for a passphrase.
#   TTY (a teletype device):
#       The teletype device of the current terminal.
#   UTIL (a programme):
#       A programme that confirms to the so-called SSh Askpass Protocol.
#
# Side-effects:
#   * If UTIL isn't given, disables and renables echo on TTY.
#   * May print an error message to STDERR.
#
# Returns:
#   0:
#       Success.
#   Non-zero:
#       An error occurred.
# shellcheck disable=2006
askpass() (
    : "${1:?'askpass: missing PROMPT'}"
    : "${2:?'missing TTY'}"
    if [ "${3-}" ]; then
        # shellcheck disable=2016
        warn 'ID of process calling %s: %d.' "$3" "`exec sh -c 'echo $PPID'`"
        "$3" "$1"
    elif [ -c "$2" ]; then
        trapsig onexit 0 2 15
        # shellcheck disable=2094
        exec 0<"$2" 2>"$2"
        # shellcheck disable=2030
        EX='stty echo 2>/dev/null; echo >&2; exec 0<&- 2>&-'
        stty -echo
        printf -- '%s ' "$1" >&2
        read -r pass
        cat <<EOF
$pass
EOF
    else
        panic 69 'No TTY. Cannot ask for password.'
    fi
)

# auth_lpass - Run lpass, but authenticate using a given password.
#
# Synopsis:
#   auth_lpass [...]
#
# Description:
#   Calls lpass and passes on all of its arguments to it.
#   Also prints the content of the global variable $LASTPASS_PWD to its STDIN.
#
# Arguments:
#   Are passed on to lpass.
#
# Global variables:
#   LASTPASS_PWD (string):
#       The LastPass master password (read-only).
#
# Returns:
#   Whatever lpass returns.
auth_lpass() {
    [ $# -gt 0 ] || panic 70 'auth_lpass: missing arguments for lpass.'
    LPASS_DISABLE_PINENTRY=1 lpass "$@" <<EOF
$LASTPASS_PWD
EOF
}


# SETTINGS
# ========

# shellcheck disable=2039
[ "$BASH_VERSION" ] && set -o posix
[ "$ZSH_VERSION"  ] && emulate sh 2>/dev/null
# shellcheck disable=2034
BIN_SH=xpg4 NULLCMD=: POSIXLY_CORRECT=x CLICOLOR_FORCE=
export BIN_SH CLICOLOR_FORCE POSIXLY_CORRECT

set -Cefu
umask 077

: "${LPASSH_ADD_LPASS_PATH_REGEX=ssh}"
export LPASS_AUTO_SYNC_TIME=30

case "${LPASSH_ADD_AGENT_DISABLE-}" in
    0|1) export LPASS_AGENT_DISABLE="$LPASSH_ADD_AGENT_DISABLE";;
esac


# SANITISE ENVIRONMENT
# ====================

# Set a secure path.
PATH=/bin:/usr/bin:/usr/local/bin
# shellcheck disable=2006
PATH="`getconf PATH`:$PATH"
# Make sure no fancy input field separator is set.
unset IFS


# SERVE PASSWORD TO SSH-ADD
# =========================

# FIXME: Explain this.

[ "${SSH_ASKPASS-}" = "$0" ] && exec cat


# INITIALISATION
# ==============

# Parse arguments.
while [ $# -gt 0 ]; do
    ARG="$1"
    case $ARG in
        -[cq])
            shift
            OPTS="${OPTS-} $ARG"
            [ "$ARG" = -q ] && QUIET=x
            ;;
        -t)
            [ "${2-}" ] || panic 64 '%s: Missing lifetime.' "$ARG"
            OPTS="${OPTS-} $ARG $2"
            shift 2
            ;;
        -[ADdeEkKLlsXx])
            panic 64 '%s: Unsupported option.' "$ARG"
            ;;
        -h)
            exec cat <<EOF
lpassh-add v1.1.0b - Unlocks SSh keys using LastPass.

Synopsis:
    lpassh-add [-ckq] [-t LIFETIME] [*KEY* [*KEY* [...]]]

Arguments:
    KEY         FIXME

Options:
    -c          Confirm every use of an identity.
    -h          Show this help screen.
    -q          Be quieter.
    -t LIFETIME Automatically re-lock keys after LIFETIME.
    -V          Show version.

See the manual for details.
EOF
            ;;
        -V)
            exec cat <<EOF
lpassh-add v1.1.0b
(c) 2018, 2019, 2020 Odin Kroeger
Released under the MIT license.
EOF
            ;;
        --)
            shift
            break
            ;;

        -*)
            panic 64 '%s: Unknown option.' "$ARG"
            :
            ;;
        *)
            break
            ;;
    esac
done

# Make sure LPASS_ASKPASS and SSH_ASKPASS point to a system programme.
for UTIL in "${LPASS_ASKPASS-}" "${SSH_ASKPASS-}"
do
    [ "${UTIL-}" ] || continue
    # shellcheck disable=2006,2046
    if [ "$UTIL" = `expr "//$UTIL" : '.*/\(.*\)'` ]; then
        ASKPASS="$UTIL"
        break
    else
        (
            IFS=/
            for ELEM in $UTIL
            do
                unset IFS
                [ "$ELEM" ] || continue
                ACC="${ACC-}/$ELEM"
                # shellcheck disable=2012,2121         
                set x `ls -d -l -n "${ACC:?}" | awk '{print $1, $3, $4}'`; shift
                [ $# -eq 3 ]      \
                    || panic 69 '%s: Cannot parse stats.' "$ACC"
                [ "$2" -eq 0 ]    \
                    || panic 69 '%s: Not owned by root.' "$ACC"
                [ "$3" -lt 1000 ] \
                    || panic 69 '%s: Not owned by a system group.' "$ACC"
                PERMS="$1"
                case ${PERMS#????} in
                    *w*) panic 69 '%s: Non-owner writeable.' "$ACC" ;;
                esac
            done
        ) || panic 69 '%s: Not secure.' "$UTIL"
        ASKPASS="$UTIL"
        break
    fi
done
export PATH IFS

# Check what TTY to read passwords from.
# shellcheck disable=2006
TTY=`tty`  || :
[ "$TTY" ] || panic 69 "Cannot determine the terminal's teletype device."

# Prepare cleanup.
trapsig onexit 0 2 15


# MAIN
# ====

# Log into LastPass if necessary.
LPASS=lpass LASTPASS_STATUS=0 LASTPASS_PWD=
lpass status --quiet || LASTPASS_STATUS=$?
if [ "$LASTPASS_STATUS" -ne 0 ]; then
    [ "${LPASSH_ADD_USERNAME-}" ] || panic 64 'Not logged into LastPass.'
    if [ "${LPASS_AGENT_DISABLE-0}" -eq 1 ]; then
        # shellcheck disable=2006
        LASTPASS_PWD=`askpass 'LastPass master password' "$TTY" "${ASKPASS-}"`
        [ "${LASTPASS_PWD-}" ] || panic 64 'No password given.'
        LPASS=auth_lpass
        # Make sure lpass reads from STDIN.
        if [ "${LASTPASS-}" ] || [ "${LASTPASS-x}" = x ]; then
            unset LPASS_ASKPASS
            export LPASS_ASKPASS
        fi
    fi
    "$LPASS" login --color=never "$LPASSH_ADD_USERNAME" 1>/dev/null 2>&1 \
        || panic 69 'Could not log into LastPass.'
    # shellcheck disable=2016
    EX="lpass logout --force >/dev/null"
fi
readonly LASTPASS_PWD

# Lookup IDs of all SSh keys.
# shellcheck disable=2006
IDS=`"$LPASS" show --id -x -G "$LPASSH_ADD_LPASS_PATH_REGEX"`
[ "$IDS" ] || \
    panic 69 '%s: No item in LastPass matches.' "$LPASSH_ADD_LPASS_PATH_REGEX"

# Check if keys have been given.
# shellcheck disable=2121
if [ $# -eq 0 ]; then
    PF="$HOME/.ssh/id_"
    set x "${PF}rsa" "${PF}dsa" "${PF}ecdsa" "${PF}ed25519"
    shift
else
    KEYS_GIVEN=x
fi

# Unlock the keys.
export SSH_ASKPASS="$0" DISPLAY=''
for KEY
do
    # Skip if there's no such key.
    if [ -e "$KEY" ]; then :; else
        [ "${KEYS_GIVEN-}" ] && warn '%s: No such file.' "$KEY"
        continue
    fi

    # Try the last Passphrase.
    # shellcheck disable=2086
    [ "${PASS-}" ] && ssh-add ${OPTS-} "$KEY" <<EOF && continue 2
$PASS
EOF

    # Try every passphrase.
    for ID in $IDS; do
        case "$ID" in *[!0-9]*) continue; esac
        eval "PASS=\"\${PASS_$ID-}\""
        if [ -z "$PASS" ]; then
            # shellcheck disable=2006
            PASS=`"$LPASS" show --field=Passphrase "$ID"` || continue
            eval "PASS_$ID=\"\$PASS\""
        fi
        # shellcheck disable=2086
        ssh-add ${OPTS-} "$KEY" <<EOF && continue 2
$PASS
EOF
    done 
    [ "${QUIET-}" ] || warn '%s: No passphrase from LastPass matches.' "$KEY"

    ITER=0 MAX_RETRIES=2
    while [ "$ITER" -lt "$MAX_RETRIES" ]; do
        case $ITER in
            0) PROMPT="Passphrase for $KEY:";;
            1) PROMPT="Wrong passphrase for $KEY. Re-try:";;
        esac
        # shellcheck disable=2006
        PASS=`askpass "$PROMPT" "$TTY" "${ASKPASS-}"` ITER=$((ITER+1))
        # shellcheck disable=2086
        ssh-add ${OPTS-} "$KEY" <<EOF && continue 2
$PASS
EOF
    done
    warn '%s: Could not unlock.' "$KEY"
done
